import java.nio.file.Files
import java.nio.file.Path
import javax.inject.Inject
import org.gradle.process.ExecOperations

interface InjectedExecOps {
    @Inject ExecOperations getExecOps()
}

plugins {
    id 'groovy'
    id 'application'
    id 'de.undercouch.download' version '5.6.0'
}

repositories {
    mavenCentral()
}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

dependencies {
    implementation 'ch.qos.logback:logback-classic:1.5.18'
    implementation 'org.slf4j:jul-to-slf4j:2.0.17'

    implementation 'org.apache.groovy:groovy:4.0.29'
    implementation 'org.apache.groovy:groovy-json:4.0.29'
    implementation 'com.google.guava:guava:33.4.8-jre'
    implementation 'org.msgpack:msgpack-core:0.9.9'
    implementation 'io.javalin:javalin:6.7.0'

    implementation platform('org.testcontainers:testcontainers-bom:2.0.3')
    implementation 'org.testcontainers:testcontainers-mysql'
    implementation "org.testcontainers:testcontainers-junit-jupiter"
    implementation 'org.hamcrest:hamcrest:2.2'
    implementation 'com.flipkart.zjsonpatch:zjsonpatch:0.4.16'
    implementation 'org.junit.jupiter:junit-jupiter-engine:5.12.2'
    implementation 'org.junit.jupiter:junit-jupiter-params:5.12.2'
    implementation 'org.junit.platform:junit-platform-launcher'

    testRuntimeOnly 'com.mysql:mysql-connector-j:9.3.0'
}

test {
}
tasks['test'].enabled = false

ext.testMatrix = ['7.0', '7.1', '7.2', '7.3', '7.4', '8.0', '8.1', '8.2', '8.3', '8.4', '8.5'].collectMany {
    [[it, 'release'], [it, 'debug'], [it, 'release-zts']]
}
ext.uuid = "id -u".execute().text.trim()

apply from: "$rootDir/gradle/images.gradle"

def dockerMirror = ext.dockerMirror
def map_tag = ext.map_tag
def repo = ext.repo
def arch = System.getProperty('os.arch')

def dockerPullTask(String tag) {
    String taskName = "dockerPull-${tag}"
    if (tasks.findByName(taskName) != null) {
        return tasks[taskName]
    }

    tasks.register("dockerPull-${tag}", Exec) {
        String imageName = "$dockerMirror/${repo}${map_tag(tag)}"
        description = "Pull ${imageName} from Docker Hub"

        onlyIf {
            Process proc = ['docker', 'image', 'inspect', imageName].execute()
            proc.waitForOrKill(5_000)
            proc.exitValue() != 0
        }

        commandLine 'docker', 'pull', imageName
    }
}

def creationDateOf(String image) {
    Process proc = ['docker', 'image', 'inspect', '--format="{{.Created}}"',  image].execute()
    proc.waitForOrKill(5_000)
    if (proc.exitValue() != 0) {
        return 0
    }
    def imageModifiedStr = proc.text.trim().replace('"', '')
    Date volumeDate = Date.from(OffsetDateTime.parse(imageModifiedStr).toInstant())
    volumeDate.time
}
def libddwafCommit() {
    def proc = ['git', '-C', "${projectDir}/../../third_party/libddwaf", 'rev-parse', 'HEAD'].execute()
    proc.waitForOrKill(5_000)
    proc.text.trim()
}

def createVolumeTask = { String volumeName ->
    String taskName = "createVolume-$volumeName"
    if (tasks.findByName(taskName) != null) {
        return tasks[taskName]
    }
    tasks.register(taskName, Exec) { Exec it ->
        def injected = project.objects.newInstance(InjectedExecOps)
        onlyIf {
            Process proc = ['docker', 'volume', 'inspect', volumeName].execute()
            proc.waitForOrKill(5_000)
            proc.exitValue() != 0
        }
        it.commandLine 'docker', 'volume', 'create', volumeName
        doLast {
            injected.execOps.exec {
                commandLine 'docker', 'run', '--rm', '-v', "${volumeName}:/vol",
                        "$dockerMirror/library/busybox",
                        'sh', '-c', "chown -R ${uuid} /vol"
            }
        }
    }
}

task downloadComposerOld(type: Download) {
    def injected = project.objects.newInstance(InjectedExecOps)
    src 'https://getcomposer.org/download/latest-2.2.x/composer.phar'
    dest 'build/composer-2.2.x.phar'
    overwrite false
    doLast {
        injected.execOps.exec {
            commandLine 'chmod', '+x', outputFiles.first().toString()
        }
    }
}

task downloadComposer(type: Download) {
    def injected = project.objects.newInstance(InjectedExecOps)
    src 'https://getcomposer.org/download/2.8.6/composer.phar'
    dest 'build/composer-2.8.6.phar'
    overwrite false
    doLast {
        injected.execOps.exec {
            commandLine 'chmod', '+x', outputFiles.first().toString()
        }
    }
}

def buildRunInDockerTask = { Map options ->
    String baseName = options.get('baseName')
    def version = options.get('version')
    def variant = options.get('variant')
    def hasVersionVariant = version && variant
    def suffix = hasVersionVariant ? "-${version}-${variant}" : ''

    String imageTag = options.get('imageTag') ?: "${options.get('baseTag', 'php')}-$version-$variant"
    String imageName = "$dockerMirror/${repo}${map_tag(imageTag)}"
    def pullTask = dockerPullTask(imageTag)

    def volumes = options.get('volumes', [:]).collectEntries { k, v ->
        [k, v + [task: createVolumeTask(k)]]
    }
    def binds = [
            ("${projectDir}/../../..".toString()):  '/project'
    ]

    if (hasVersionVariant && options.get('needsTracer', true)) {
        def volName = "php-tracer-${version}-${variant}"
        volumes[volName] = [
                mountPoint: '/project/tmp',
                task: createVolumeTask(volName),
        ]
    }
    if (hasVersionVariant && options.get('needsAppsec', true)) {
        def volName = "php-appsec-${version}-${variant}"
        volumes[volName] = [
                mountPoint: '/appsec',
                task: createVolumeTask(volName),
        ]
    }
    if (options.get('needsBoostCache', true)) {
        if (project.hasProperty('localBoostCache')) {
            binds[project.getProperty('localBoostCache')] = '/root/.boost'
        } else {
            volumes['php-appsec-boost-cache'] = [
                    mountPoint: '/root/.boost',
                    task: createVolumeTask('php-appsec-boost-cache'),
            ]
        }
    }
    if (options.get('needsCargoCache', true)) {
        volumes['php-tracer-cargo-cache'] = [
                mountPoint: '/root/.cargo/registry',
                task: createVolumeTask('php-tracer-cargo-cache'),
        ]
        volumes['php-tracer-cargo-cache-git'] = [
                mountPoint: '/root/.cargo/git',
                task: createVolumeTask('php-tracer-cargo-cache-git'),
        ]
    }

    def composerDlTask
    if (options.get('composer', false)) {
        if (version in ['7.0', '7.1']) {
            composerDlTask = tasks['downloadComposerOld']
        } else {
            composerDlTask = tasks['downloadComposer']
        }
        String composerFile = composerDlTask.outputFiles.first()
        binds[composerFile] = '/usr/local/bin/composer'
    }

    def t = tasks.register("$baseName$suffix", Exec) {
        if (options['description']) {
            description = hasVersionVariant ? "${options['description']} for PHP $version $variant" : options['description']

            def inputsSpec = options.get('inputs', [:])
            inputsSpec.get('dirs', []).each { dir ->
                inputs.files fileTree(dir).matching {
                    include '**/*'
                    exclude { FileTreeElement element ->
                        Path p = element.file.toPath()
                        if (Files.isSymbolicLink(p)) {
                            // exclude if the target does not exist
                            if (!Files.exists(Files.readSymbolicLink(p))) {
                                logger.warn("Excluding broken symlink: $p")
                                return true
                            }
                        }
                        false // do not exclude
                    }
                }
            }
            inputsSpec.get('files', []).each {
                inputs.file it
            }

            if (!options['outputs']) {
                outputs.upToDateWhen { false }
            } else {
                String volumeName = hasVersionVariant ? "${options['outputs']['volume']}${suffix}" : options['outputs']['volume']
                def files = options['outputs']['files']
                outputs.upToDateWhen {
                    Process proc = ['docker', 'run', '--rm', '--mount',
                                    "type=volume,src=$volumeName,dst=/vol",
                                    "$dockerMirror/library/busybox", 'sh', '-c',
                                    "stat -c %Y ${files.collect { "'/vol/$it'" }.join(' ')} 2>/dev/null | sort -n | head -1"]
                            .execute()

                    proc.waitForOrKill(5_000)
                    if (proc.exitValue() != 0) {
                        return false
                    }
                    def procOutput = proc.text.trim()
                    if (procOutput == '') {
                        return false
                    }
                    long outputsTime = procOutput.toLong() * 1000
                    long latestInputDate = inputs.files.collect { it.lastModified() }.max()
                    if (latestInputDate > outputsTime) {
                        return false
                    }

                    long imageTime = creationDateOf(imageName)
                    imageTime < outputsTime
                }
            }

            def commandLine = [
                    'docker', 'run', '--init', '--rm',
                    '--entrypoint', '/bin/bash',
            ]
            if (!options.get('runAsRoot', false)) {
                commandLine.addAll(['--user', uuid, '-e', 'HOME=/tmp'])
            }
            binds.each { source, dest ->
                commandLine.addAll(['--mount', "type=bind,src=${source},dst=${dest}"])
            }
            volumes.each { volumeName, volumeSpec ->
                commandLine << '--mount'
                def mountOpts = "type=volume,src=${volumeName},dst=${volumeSpec['mountPoint']}"
                if (volumeSpec.get('readonly', false)) {
                    mountOpts += ',readonly'
                }
                commandLine << mountOpts
                dependsOn volumeSpec['task']
            }
            commandLine << imageName
            dependsOn pullTask

            commandLine.addAll(options['command'])
            it.commandLine commandLine

            if (composerDlTask) {
                dependsOn composerDlTask
            }

            options.get('taskDependencies', []).each { dep ->
                dependsOn dep
            }
        }
    }

    if (options.containsKey('outputs') && options['outputs'].containsKey('volume')) {
        String volName = hasVersionVariant ? "${options['outputs']['volume']}${suffix}" : options['outputs']['volume']
        String taskName = "cleanVolume-${volName}"
        if (!tasks.findByName(taskName)) {
            def task = tasks.register(taskName, Exec) {
                description = hasVersionVariant ? "Clean volume ${options['outputs']['volume']} for PHP $version $variant" : "Clean volume ${options['outputs']['volume']}"
                commandLine 'docker', 'volume', 'rm', '-f', volName
            }
            tasks['clean'].dependsOn task
        }
    }

    t
}

def buildTracerTask = { String version, String variant ->
    buildRunInDockerTask(
            baseName: 'buildTracer',
            baseTag: 'php',
            version: version,
            variant: variant,
            needsAppsec: false,
            description: 'Build tracer for PHP',
            inputs: [
                    dirs: [
                            '../../../ext',
                            '../../../zend_abstract_interface',
                            '../../../libdatadog',
                            '../../../ddtrace.sym',
                    ],
            ],
            outputs: [
                    volume: 'php-tracer',
                    files: ['build_extension/modules/ddtrace.so'],
            ],
            command: [
                    '-e', '-c',
                    '''
                    cd /project
                    PHPRC= RUST_DEBUG_BUILD=1 make /project/tmp/build_extension/modules/ddtrace.so
                    '''
            ]
    )
}

def buildAppSecTask = { String version, String variant ->
    buildRunInDockerTask(
            baseName: 'buildAppsec',
            baseTag: 'php',
            version: version,
            variant: variant,
            needsTracer: false,
            description: 'Build appsec for PHP',
            inputs: [
                    dirs: [
                            '../../../cmake',
                            '../../../zend_abstract_interface',
                            '../../cmake',
                            '../../third_party',
                            '../../src'],
                    files: ['../../CMakeLists.txt'],
            ],
            outputs: [
                    volume: 'php-appsec',
                    files: ['ddappsec.so', 'libddappsec-helper.so'],
            ],
            command: [
                    '-e', '-c',
                    """
                    cd /appsec
                    test -f CMakeCache.txt || \\
                        cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo \\
                              -DCMAKE_INSTALL_PREFIX=/appsec \\
                              -DDD_APPSEC_ENABLE_PATCHELF_LIBC=ON \\
                              -DGIT_COMMIT=${libddwafCommit()} \\
                              -DDD_APPSEC_TESTING=ON /project/appsec
                    make -j extension ddappsec-helper && \\
                        touch ddappsec.so libddappsec-helper.so
                """
            ]
    )
}

def runUnitTestsTask = { String phpVersion, String variant ->
    def env = ''
    if (project.hasProperty('tests')) {
        env = "TESTS='${project.getProperty('tests')}' "
    }
    def task = buildRunInDockerTask(
            baseName: 'xtest',
            baseTag: 'php',
            version: phpVersion,
            variant: variant,
            description: 'Build appsec for PHP',
            command: [
                    '-e', '-c',
                    """
                    cd /appsec
                    ${env}make -j xtest
                    """
            ]
    )

    task.configure {
        dependsOn "buildTracer-$phpVersion-$variant"
        dependsOn "buildAppsec-$phpVersion-$variant"
    }
}

def runMainTask = { String phpVersion, String variant ->
    tasks.create("runMain$phpVersion-$variant", JavaExec) {
        mainClass = project.property('testClass')
        classpath = sourceSets.test.runtimeClasspath
        standardInput = System.in

        if (project.hasProperty('XDEBUG')) {
            systemProperty 'XDEBUG', '1'
        }
        systemProperty 'PHP_VERSION', phpVersion
        systemProperty 'VARIANT', variant

        if (project.hasProperty('useHelperRust') || project.hasProperty('useHelperRustCoverage')) {
            systemProperty 'USE_HELPER_RUST', '1'
        }
        if (project.hasProperty('useHelperRustCoverage')) {
            systemProperty 'USE_HELPER_RUST_COVERAGE', '1'
        }

        dependsOn "buildTracer-$phpVersion-$variant"
        dependsOn "buildAppsec-$phpVersion-$variant"
        if (project.hasProperty('useHelperRustCoverage')) {
            dependsOn 'buildHelperRustWithCoverage'
        } else if (project.hasProperty('useHelperRust')) {
            dependsOn 'buildHelperRust'
        }
    }
}

testMatrix.each { spec ->
    String phpVersion = spec[0]
    String variant = spec[1]

    buildTracerTask(phpVersion, variant)
    buildAppSecTask(phpVersion, variant)
    runUnitTestsTask(phpVersion, variant)
    if (project.hasProperty('testClass')) {
        runMainTask(phpVersion, variant)
    }

    def task = tasks.register("test${phpVersion}-$variant", Test) {
        group = 'Verification'
        description = "Run tests for PHP ${phpVersion} ${variant}"

        it.outputs.upToDateWhen { false }

        it.useJUnitPlatform {
            includeEngines('junit-jupiter')
            excludeEngines('junit-vintage')
        }

        it.testClassesDirs = sourceSets.test.output.classesDirs
        it.classpath = sourceSets.test.runtimeClasspath

        it.systemProperty 'PHP_VERSION', phpVersion
        it.systemProperty 'VARIANT', variant
        if (project.hasProperty('XDEBUG')) {
            it.systemProperty 'XDEBUG', '1'
        }
        if (project.hasProperty('useHelperRust') || project.hasProperty('useHelperRustCoverage')) {
            it.systemProperty 'USE_HELPER_RUST', '1'
        }
        if (project.hasProperty('useHelperRustCoverage')) {
            it.systemProperty 'USE_HELPER_RUST_COVERAGE', '1'
        }

        it.systemProperty 'DOCKER_MIRROR', dockerMirror
        if (!project.hasProperty("floatingImageTags")) {
            it.systemProperty 'TAG_MAPPINGS', "$rootDir/gradle/tag_mappings.gradle"
        }

        dependsOn "buildTracer-${phpVersion}-${variant}"
        dependsOn "buildAppsec-${phpVersion}-${variant}"
        if (project.hasProperty('useHelperRustCoverage')) {
            dependsOn 'buildHelperRustWithCoverage'
        } else if (project.hasProperty('useHelperRust')) {
            dependsOn 'buildHelperRust'
        }

        if (version in ['7.0', '7.1']) {
            dependsOn downloadComposerOld
        } else {
            dependsOn downloadComposer
        }
    }

    tasks['check'].dependsOn task
}

task loadCaches(type: Exec) {
    description = "Load the docker caches"
    inputs.file "${project.buildDir}/php-appsec-volume-caches-${arch}.tar.gz"

    commandLine 'docker', 'run', '--rm',
            '-v', 'php-tracer-cargo-cache:/caches/php-tracer-cargo-cache',
            '-v', 'php-tracer-cargo-cache-git:/caches/php-tracer-cargo-cache-git',
            '-v', 'php-appsec-boost-cache:/caches/php-appsec-boost-cache',
            '-v', "${project.buildDir}:/build",
            "$dockerMirror/library/busybox",
            'sh', '-c',
            "tar -xzf /build/php-appsec-volume-caches-${arch}.tar.gz -C /caches && \
                chown -R ${uuid} /caches"

    dependsOn 'createVolume-php-tracer-cargo-cache'
    dependsOn 'createVolume-php-tracer-cargo-cache-git'
    dependsOn 'createVolume-php-appsec-boost-cache'
}

task saveCaches(type: Exec) {
    description = "Save the docker caches"
    outputs.file "${project.buildDir}/php-appsec-volume-caches-${arch}.tar.gz"
    commandLine 'docker', 'run', '--rm',
            '-e', "UUID=${uuid}",
            '-v', 'php-tracer-cargo-cache:/caches/php-tracer-cargo-cache',
            '-v', 'php-tracer-cargo-cache-git:/caches/php-tracer-cargo-cache-git',
            '-v', 'php-appsec-boost-cache:/caches/php-appsec-boost-cache',
            '-v', "${project.buildDir}:/build",
            "$dockerMirror/library/busybox",
            'sh', '-c',
            """tar -czf /build/php-appsec-volume-caches-${arch}.tar.gz \
              -C /caches php-tracer-cargo-cache php-tracer-cargo-cache-git php-appsec-boost-cache && \
              chown \$UUID /build/php-appsec-volume-caches-${arch}.tar.gz"""
}

// libddwaf shared library build (for helper-rust)
buildRunInDockerTask(
        baseName: 'buildLibddwaf',
        imageTag: 'php-deps',
        description: 'Build libddwaf shared library',
        needsBoostCache: false,
        needsCargoCache: false,
        inputs: [
                dirs: ['../../third_party/libddwaf'],
        ],
        outputs: [
                volume: 'php-libddwaf',
                files: ['lib/libddwaf.so', 'include/ddwaf.h'],
        ],
        volumes: [
                'php-libddwaf': [mountPoint: '/libddwaf-prefix'],
        ],
        command: [
                '-e', '-c',
                """
                git config --global --add safe.directory '*'

                mkdir -p /tmp/libddwaf-build
                cd /tmp/libddwaf-build
                cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo \\
                      -DCMAKE_INSTALL_PREFIX=/libddwaf-prefix \\
                      -DLIBDDWAF_BUILD_SHARED=ON \\
                      -DLIBDDWAF_BUILD_STATIC=OFF \\
                      -DLIBDDWAF_TESTING=OFF \\
                      /project/appsec/third_party/libddwaf
                make -j install
                touch /libddwaf-prefix/lib/libddwaf.so /libddwaf-prefix/include/ddwaf.h
                """
        ]
)

// Shared configuration for helper-rust tasks
def helperRustInputs = [
        dirs: ['../../helper-rust/src', '../../third_party/libddwaf-rust'],
        files: [
                '../../helper-rust/Cargo.toml',
                '../../helper-rust/Cargo.lock',
                '../../helper-rust/build.rs',
                '../../helper-rust/glibc_compat.c',
                '../../helper-rust/coverage_init.c',
                '../../helper-rust/outline_atomics.c',
        ],
]

def helperRustEnvSetup = '''
git config --global --add safe.directory '*'
export PATH="/root/.cargo/bin:$PATH"
export RUSTUP_HOME=/root/.rustup
export CARGO_HOME=/root/.cargo
cd /project/appsec/helper-rust
export CARGO_TARGET_DIR=/helper-rust-build/cargo-target
'''

// Build helper-rust (Cargo downloads prebuilt libddwaf 2.x)
buildRunInDockerTask(
        baseName: 'buildHelperRust',
        imageTag: 'php-deps',
        description: 'Build helper-rust',
        needsBoostCache: false,
        inputs: helperRustInputs,
        outputs: [
                volume: 'php-helper-rust',
                files: ['libddappsec-helper.so'],
        ],
        volumes: [
                'php-helper-rust': [mountPoint: '/helper-rust-build'],
        ],
        command: [
                '-e', '-c',
                """
                ${helperRustEnvSetup}
                cargo build -v
                cp /helper-rust-build/cargo-target/debug/libddappsec_helper_rust.so /helper-rust-build/libddappsec-helper.so
                """
        ]
)

// Test and lint helper-rust (Cargo downloads prebuilt libddwaf 2.x)
buildRunInDockerTask(
        baseName: 'testHelperRust',
        imageTag: 'php-deps',
        description: 'Test and lint helper-rust',
        needsBoostCache: false,
        inputs: helperRustInputs,
        volumes: [
                'php-helper-rust': [mountPoint: '/helper-rust-build'],
        ],
        command: [
                '-e', '-c',
                """
                ${helperRustEnvSetup}

                echo '=== Checking formatting ==='
                cargo fmt --check

                echo '=== Building helper-rust ==='
                cargo build --release

                echo '=== Running cargo test ==='
                cargo test --release

                echo '=== Build and test successful ==='
                """
        ]
)

// Generate coverage from helper-rust unit tests (Cargo downloads prebuilt libddwaf 2.x)
buildRunInDockerTask(
        baseName: 'coverageHelperRust',
        imageTag: 'php-deps',
        description: 'Generate coverage for helper-rust unit tests',
        needsBoostCache: false,
        inputs: helperRustInputs,
        outputs: [
                volume: 'php-helper-rust-coverage',
                files: ['coverage-unit.lcov'],
        ],
        volumes: [
                'php-helper-rust-coverage': [mountPoint: '/helper-rust-build'],
        ],
        command: [
                '-e', '-c',
                """
                ${helperRustEnvSetup}

                echo '=== Installing cargo-llvm-cov ==='
                rustup component add llvm-tools-preview
                ARCH=\$(uname -m)
                if [ "\$ARCH" = "aarch64" ]; then
                    LLVM_COV_ARCH="aarch64-unknown-linux-musl"
                else
                    LLVM_COV_ARCH="x86_64-unknown-linux-musl"
                fi
                curl -LsSf "https://github.com/taiki-e/cargo-llvm-cov/releases/download/v0.6.23/cargo-llvm-cov-\${LLVM_COV_ARCH}.tar.gz" | tar xzf - -C /root/.cargo/bin

                echo '=== Running cargo test with coverage ==='
                cargo llvm-cov test --release --lcov --output-path /helper-rust-build/coverage-unit.lcov

                echo '=== Coverage data generated ==='
                """
        ]
)

// Build helper-rust with coverage instrumentation for integration tests
buildRunInDockerTask(
        baseName: 'buildHelperRustWithCoverage',
        imageTag: 'php-deps',
        description: 'Build helper-rust with coverage instrumentation',
        needsBoostCache: false,
        inputs: helperRustInputs,
        outputs: [
                volume: 'php-helper-rust-coverage',
                files: ['libddappsec-helper.so'],
        ],
        volumes: [
                'php-helper-rust-coverage': [mountPoint: '/helper-rust-build'],
        ],
        command: [
                '-e', '-c',
                """
                ${helperRustEnvSetup}

                echo '=== Building helper-rust with coverage instrumentation ==='

                # Determine target triple
                ARCH=\$(uname -m)
                if [ "\$ARCH" = "aarch64" ]; then
                    RUST_TARGET="aarch64-unknown-linux-gnu"
                else
                    RUST_TARGET="x86_64-unknown-linux-gnu"
                fi

                # Create .cargo/config.toml with target-specific rustflags.
                # Using [target.<triple>.rustflags] ensures flags only apply to target code,
                # not to build scripts (which compile for host without --target flags).
                mkdir -p .cargo
                cat > .cargo/config.toml << EOF
[target.\$RUST_TARGET]
rustflags = ["-C", "instrument-coverage"]
EOF

                export LLVM_PROFILE_FILE='/helper-rust-build/coverage/default-%m-%p.profraw'
                mkdir -p /helper-rust-build/coverage
                # Make coverage dir world-writable so sidecar (running as www-data) can write profraw files
                chmod 777 /helper-rust-build/coverage
                cargo build --release --target \$RUST_TARGET --features coverage
                cp /helper-rust-build/cargo-target/\$RUST_TARGET/release/libddappsec_helper_rust.so /helper-rust-build/libddappsec-helper.so

                # Clean up generated config
                rm -rf .cargo

                echo '=== Coverage-instrumented build ready ==='
                """
        ]
)

// Generate coverage report from integration test profraw files
buildRunInDockerTask(
        baseName: 'generateHelperRustIntegrationCoverage',
        imageTag: 'php-deps',
        description: 'Generate coverage report from helper-rust integration tests',
        needsBoostCache: false,
        inputs: [dirs: []],
        outputs: [
                volume: 'php-helper-rust-coverage',
                files: ['coverage-integration.lcov'],
        ],
        volumes: [
                'php-helper-rust-coverage': [mountPoint: '/helper-rust-build'],
        ],
        taskDependencies: [],
        command: [
                '-e', '-c',
                """
                export PATH="/root/.cargo/bin:\$PATH"
                export RUSTUP_HOME=/root/.rustup
                export CARGO_HOME=/root/.cargo

                cd /helper-rust-build/coverage
                if ls *.profraw 1>/dev/null 2>&1; then
                    echo 'Found profraw files:'
                    ls -la *.profraw

                    # Detect the architecture-specific toolchain path
                    ARCH=\$(uname -m)
                    if [ "\$ARCH" = "aarch64" ]; then
                        RUST_TARGET="aarch64-unknown-linux-gnu"
                    else
                        RUST_TARGET="x86_64-unknown-linux-gnu"
                    fi
                    LLVM_TOOLS="/root/.rustup/toolchains/1.84.1-\${RUST_TARGET}/lib/rustlib/\${RUST_TARGET}/bin"

                    \${LLVM_TOOLS}/llvm-profdata merge -sparse *.profraw -o merged.profdata
                    \${LLVM_TOOLS}/llvm-cov export \\
                        /helper-rust-build/libddappsec-helper.so \\
                        -format=lcov \\
                        -instr-profile=merged.profdata \\
                        > /helper-rust-build/coverage-integration.lcov
                    echo 'Coverage report generated'
                else
                    echo 'No profraw files found - coverage may not have been collected'
                    exit 1
                fi
                """
        ]
)

if (hasProperty('buildScan')) {
    buildScan {
        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
        termsOfServiceAgree = 'yes'
    }
}

// vim: set et sw=4 ts=4:
