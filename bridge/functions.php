<?php

namespace DDTrace\Bridge;

function dd_tracing_enabled()
{
    $value = getenv('DD_TRACE_ENABLED');
    if (false === $value) {
        // Not setting the env means we default to enabled.
        return true;
    }

    $value = trim(strtolower($value));
    if ($value === '0' || $value === 'false') {
        return false;
    } else {
        return true;
    }
}

/**
 * Checks if any of the provided classes exists.
 *
 * @param string[] $sentinelClasses
 * @return bool
 */
function any_class_exists(array $sentinelClasses)
{
    foreach ($sentinelClasses as $sentinelClass) {
        if (class_exists($sentinelClass)) {
            return true;
        }
    }

    return false;
}

/**
 * Extracts an array ['My\Autoloader\Class', 'method'] if the loader class and methods are in a known format, otherwise
 * it returns null.
 *
 * @param \callable $loader As in http://php.net/manual/en/language.types.callable.php
 * @return array|null
 */
function extract_autoloader_class_and_method($loader)
{
    // Covers case: spl_autoloader_register('Some\Class::load')
    if (is_string($loader)) {
        $parts = explode('::', $loader);
        return count($parts) === 2 ? [$parts[0], $parts[1]] : null;
    }

    // Covers case: spl_autoloader_register(['Some\Class', 'load'])
    if (is_array($loader) && count($loader) === 2) {
        if (is_string($loader[0])) {
            return [$loader[0], $loader[1]];
        } elseif (is_object($loader[0])) {
            return [get_class($loader[0]), $loader[1]];
        } else {
            return null;
        }
    }

    // Case not covered: spl_autoloader_register(null);
    // Case not covered: spl_autoloader_register(function () {});
    return null;
}

/**
 * Traces spl_autoload_register in order to provide hooks for auto-instrumentation to be executed.
 */
function dd_wrap_autoloader()
{
    $dd_autoload_called = false;

    // First step, we register DDTrace autoloader at the begin of the stack, in case some other extension has registered
    // its own.
    spl_autoload_register(['\DDTrace\Bridge\Autoloader', 'load'], true, true);

    // Autoloader classes that triggers a check to un-register our hook into 'spl_autoload_register' function.
    // We may need to unregister our autoloader in some special circumstanced because autoloader's callbacks may
    // be private or protected and because of https://github.com/DataDog/dd-trace-php/issues/224 we are currently
    // not able to handle this scenario.
    $untraceTriggerClasses = [
        'Composer\Autoload\ClassLoader',
    ];

    // When a check to un-register our hook into 'spl_autoload_register' function is triggered, if any of the classes
    // listed here exists, then we un-register our 'spl_autoload_register' wrapper.
    // This check is required because some frameworks (e.g. Zend 1) register autoloaders which are relevant to our
    // instrumentation after the one provided by composer.
    $sentinelClasses = [
        'Symfony\Component\HttpKernel\Kernel',
    ];

    // Instead of tracing autoloaders statically, we should trace them dynamically. This cannot be done at the moment
    // because of https://github.com/DataDog/dd-trace-php/issues/224 and the fact that in some cases, e.g. Symfony 3.3's
    // `Symfony\Component\Config\Resource\ClassExistenceResource::throwOnRequiredClass` loaders are private (note:
    // this method has been transformed to public in Symfony 3.4).
    // As soon as this is fixed we can trace `spl_autoload_register` function and use it as a hook instead of
    // statically hooking into a limited number of class loaders.
    dd_trace('spl_autoload_register', function () use (&$dd_autoload_called, $untraceTriggerClasses, $sentinelClasses) {
        $args = func_get_args();
        $originalAutoloaderRegistered = call_user_func_array('spl_autoload_register', $args);

        $loader = $args[0];
        $extractedClassAndMethod = extract_autoloader_class_and_method($loader);

        if (empty($extractedClassAndMethod)) {
            return $originalAutoloaderRegistered;
        }

        list ($loaderClass, $loaderMethod) = $extractedClassAndMethod;

        // If we detect the composer autogenerated autoloader, there is nothing we have to do at this time.
        // We wait for the next class, which is the actual composer autoloader, to check if the user
        // declared datadog/dd-trace in its own composer.json. If so, then we use this instead of the one
        // provided with the extension.
        $generatedComposerClassPrefix = 'ComposerAutoloaderInit';
        if (substr($loaderClass, 0, strlen($generatedComposerClassPrefix)) === $generatedComposerClassPrefix) {
            return $originalAutoloaderRegistered;
        }

        // Why unregistering spl_autoload_register?
        // In some cases (e.g. Symfony) this 'spl_autoload_register' function is called within a private scope and at
        // the moment we are working to have this use case properly handled by the extension. In the meantime we provide
        // this workaround.
        if ($loaderClass === 'Composer\Autoload\ClassLoader' && any_class_exists($sentinelClasses)) {
            dd_untrace('spl_autoload_register');
        }

        if (!$dd_autoload_called
                // If `\DDTrace\Tracer` exists, then the user defined this entry in the composer.json file and we don't
                // need to add the autoloader that loads sources from the bundled version.
                && !class_exists('\DDTrace\Tracer')
        ) {
            $dd_autoload_called = true;
            require_once __DIR__ . '/dd_autoloader.php';
            spl_autoload_register(['\DDTrace\Bridge\Autoloader', 'load']);
        }

        require __DIR__ . '/dd_init.php';

        return $originalAutoloaderRegistered;
    });
}
