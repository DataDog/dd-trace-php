<?php

namespace DDTrace\Bridge;

/**
 * Tells whether or not a class exists. It never throws an exception.
 *
 * @param string $class
 * @return bool
 */
function dd_safe_class_exists($class)
{
    $error = false;
    set_error_handler(function () use (&$error) {
        $error = true;
    });
    $result = class_exists($class);
    restore_error_handler();
    return $error === true ? false : $result;
}

/**
 * Tells whether or not any of the provided classes exist. It never throws an exception.
 *
 * @param string[] $classes
 * @return bool
 */
function dd_safe_any_class_exists(array $classes)
{
    foreach ($classes as $class) {
        if (dd_safe_class_exists($class)) {
            return true;
        }
    }

    return false;
}

/**
 * Tells whether or not tracing is enabled without having to fire the auto-loading mechanism.
 *
 * @return bool
 */
function dd_tracing_enabled()
{
    $value = getenv('DD_TRACE_ENABLED');
    if (false === $value) {
        // Not setting the env means we default to enabled.
        return true;
    }

    $value = trim(strtolower($value));
    if ($value === '0' || $value === 'false') {
        return false;
    } else {
        return true;
    }
}

/**
 * Checks if any of the provided classes exists.
 *
 * @param string[] $sentinelClasses
 * @return bool
 */
function any_class_exists(array $sentinelClasses)
{
    foreach ($sentinelClasses as $sentinelClass) {
        if (class_exists($sentinelClass)) {
            return true;
        }
    }

    return false;
}

/**
 * Extracts an array ['My\Autoloader\Class', 'method'] if the loader class and methods are in a known format, otherwise
 * it returns null.
 *
 * @param \callable $loader As in http://php.net/manual/en/language.types.callable.php
 * @return array|null
 */
function extract_autoloader_class_and_method($loader)
{
    // Covers case: spl_autoloader_register('Some\Class::load')
    if (is_string($loader)) {
        $parts = explode('::', $loader);
        return count($parts) === 2 ? [$parts[0], $parts[1]] : null;
    }

    // Covers case: spl_autoloader_register(['Some\Class', 'load'])
    if (is_array($loader) && count($loader) === 2) {
        if (is_string($loader[0])) {
            return [$loader[0], $loader[1]];
        } elseif (is_object($loader[0])) {
            return [get_class($loader[0]), $loader[1]];
        } else {
            return null;
        }
    }

    // Case not covered: spl_autoloader_register(null);
    // Case not covered: spl_autoloader_register(function () {});
    return null;
}

/**
 * Registers the Datadog.
 */
function dd_register_autoloader()
{
    require_once __DIR__ . '/dd_autoloader.php';
    spl_autoload_register(['\DDTrace\Bridge\Autoloader', 'load'], true, true);
}

/**
 * Unregisters the Datadog.
 */
function dd_unregister_autoloader()
{
    spl_autoload_unregister(['\DDTrace\Bridge\Autoloader', 'load']);
}

/**
 * Traces spl_autoload_register in order to provide hooks for auto-instrumentation to be executed.
 */
function dd_wrap_autoloader()
{
    dd_register_autoloader();

    // First step, we register DDTrace autoloader at the begin of the stack, in case some other extension has registered
    // its own.

    // When a check to un-register our hook into 'spl_autoload_register' function is triggered, if any of the classes
    // listed here exists, then we un-register our 'spl_autoload_register' wrapper.
    // This check is required because some frameworks (e.g. Zend 1) register autoloaders which are relevant to our
    // instrumentation after the one provided by composer.
    $sentinelClasses = [
        'Symfony\Component\HttpKernel\Kernel',
    ];

    // Composer auto-generates a class loader with a varying name which follows the pattern
    // `ComposerAutoloaderInitaa9e6eaaeccc2dd24059c64bd3ff094c`. The name of this class varies and this variable is
    // used to keep track of the actual name.
    $composerAutogeneratedClass = null;

    // We use the 'spl_autoload_register' as the auto-instrumentation hook because as new loaders are available we can
    // detect classes for which we provide auto-instrumentation.
    dd_trace('spl_autoload_register', function () use ($sentinelClasses, &$composerAutogeneratedClass) {
        $args = func_get_args();
        $originalAutoloaderRegistered = call_user_func_array('spl_autoload_register', $args);

        $loader = $args[0];
        $extractedClassAndMethod = extract_autoloader_class_and_method($loader);

        if (empty($extractedClassAndMethod)) {
            return $originalAutoloaderRegistered;
        }

        list ($loaderClass, $loaderMethod) = $extractedClassAndMethod;

        // If we detect the composer autogenerated autoloader, there is nothing we have to do at this time.
        // We wait for the next class, which is the actual composer autoloader, to check if the user
        // declared datadog/dd-trace in its own composer.json. If so, then we use this instead of the one
        // provided with the extension.
        $generatedComposerClassPrefix = 'ComposerAutoloaderInit';
        if (substr($loaderClass, 0, strlen($generatedComposerClassPrefix)) === $generatedComposerClassPrefix) {
            $composerAutogeneratedClass = $loaderClass;
            return $originalAutoloaderRegistered;
        }

        if ($loaderClass === 'Composer\Autoload\ClassLoader') {
            // If users declared a dependency on `datadog/dd-trace`, we want to honor that!
            if (method_exists('Composer\Autoload\ClassLoader', 'loadClass')
                    && null !== $composerAutogeneratedClass
                    && method_exists($composerAutogeneratedClass, 'getLoader')
            ) {
                $actualComposerLoader = call_user_func([$composerAutogeneratedClass, 'getLoader']);
                if (true === $actualComposerLoader->loadClass('\DDTrace\Tracer')) {
                    dd_unregister_autoloader();
                }
            }

            // Why unregistering spl_autoload_register?
            // In some cases (e.g. Symfony 3.3) this 'spl_autoload_register' function is called within a private scope
            // and at the moment we are working to have this use case properly handled by the extension.
            // In the meantime we provide this workaround.
            // This issue can be followed to know when this workaround can be removed:
            // https://github.com/DataDog/dd-trace-php/issues/224
            if (dd_safe_any_class_exists($sentinelClasses)) {
                dd_untrace('spl_autoload_register');
            }
        }

        // Our instrumentation code calls class_exists many times. We either replace those calls with a safe version
        // or suppress errors here. For now we do this but to be evaluated for the future.
        // Note #1: development and test of library integrations DO NOT rely on auto-instrumentation, so exceptions
        // would not be hidden in tests.
        // Note #2: During the init process we ONLY register integrations, no user-land code is executed, so the lines
        // below DO NOT hide any user-land exception/error.
        set_error_handler(function () {
        });
        require __DIR__ . '/dd_init.php';
        restore_error_handler();

        return $originalAutoloaderRegistered;
    });
}
