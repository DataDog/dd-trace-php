/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: proto/profile.proto */

#ifndef PROTOBUF_C_proto_2fprofile_2eproto__INCLUDED
#define PROTOBUF_C_proto_2fprofile_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Perftools__Profiles__Profile Perftools__Profiles__Profile;
typedef struct _Perftools__Profiles__ValueType Perftools__Profiles__ValueType;
typedef struct _Perftools__Profiles__Sample Perftools__Profiles__Sample;
typedef struct _Perftools__Profiles__Label Perftools__Profiles__Label;
typedef struct _Perftools__Profiles__Mapping Perftools__Profiles__Mapping;
typedef struct _Perftools__Profiles__Location Perftools__Profiles__Location;
typedef struct _Perftools__Profiles__Line Perftools__Profiles__Line;
typedef struct _Perftools__Profiles__Function Perftools__Profiles__Function;


/* --- enums --- */


/* --- messages --- */

struct  _Perftools__Profiles__Profile
{
  ProtobufCMessage base;
  /*
   * A description of the samples associated with each Sample.value.
   * For a cpu profile this might be:
   *   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
   * For a heap profile, this might be:
   *   [["allocations","count"], ["space","bytes"]],
   * If one of the values represents the number of events represented
   * by the sample, by convention it should be at index 0 and use
   * sample_type.unit == "count".
   */
  size_t n_sample_type;
  Perftools__Profiles__ValueType **sample_type;
  /*
   * The set of samples recorded in this profile.
   */
  size_t n_sample;
  Perftools__Profiles__Sample **sample;
  /*
   * Mapping from address ranges to the image/binary/library mapped
   * into that address range.  mapping[0] will be the main binary.
   */
  size_t n_mapping;
  Perftools__Profiles__Mapping **mapping;
  /*
   * Useful program location
   */
  size_t n_location;
  Perftools__Profiles__Location **location;
  /*
   * Functions referenced by locations
   */
  size_t n_function;
  Perftools__Profiles__Function **function;
  /*
   * A common table for strings referenced by various messages.
   * string_table[0] must always be "".
   */
  size_t n_string_table;
  char **string_table;
  /*
   * frames with Function.function_name fully matching the following
   * regexp will be dropped from the samples, along with their successors.
   */
  /*
   * Index into string table.
   */
  int64_t drop_frames;
  /*
   * frames with Function.function_name fully matching the following
   * regexp will be kept, even if it matches drop_functions.
   */
  /*
   * Index into string table.
   */
  int64_t keep_frames;
  /*
   * Time of collection (UTC) represented as nanoseconds past the epoch.
   */
  int64_t time_nanos;
  /*
   * Duration of the profile, if a duration makes sense.
   */
  int64_t duration_nanos;
  /*
   * The kind of events between sampled ocurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   */
  Perftools__Profiles__ValueType *period_type;
  /*
   * The number of events between sampled occurrences.
   */
  int64_t period;
  /*
   * Freeform text associated to the profile.
   */
  /*
   * Indices into string table.
   */
  size_t n_comment;
  int64_t *comment;
  /*
   * Index into the string table of the type of the preferred sample
   * value. If unset, clients should default to the last sample value.
   */
  int64_t default_sample_type;
};
#define PERFTOOLS__PROFILES__PROFILE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__profile__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0, 0, 0, 0, NULL, 0, 0,NULL, 0 }


/*
 * ValueType describes the semantics and measurement units of a value.
 */
struct  _Perftools__Profiles__ValueType
{
  ProtobufCMessage base;
  /*
   * Index into string table.
   */
  int64_t type;
  /*
   * Index into string table.
   */
  int64_t unit;
};
#define PERFTOOLS__PROFILES__VALUE_TYPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__value_type__descriptor) \
    , 0, 0 }


/*
 * Each Sample records values encountered in some program
 * context. The program context is typically a stack trace, perhaps
 * augmented with auxiliary information like the thread-id, some
 * indicator of a higher level request being handled etc.
 */
struct  _Perftools__Profiles__Sample
{
  ProtobufCMessage base;
  /*
   * The ids recorded here correspond to a Profile.location.id.
   * The leaf is at location_id[0].
   */
  size_t n_location_id;
  uint64_t *location_id;
  /*
   * The type and unit of each value is defined by the corresponding
   * entry in Profile.sample_type. All samples must have the same
   * number of values, the same as the length of Profile.sample_type.
   * When aggregating multiple samples into a single sample, the
   * result has a list of values that is the elemntwise sum of the
   * lists of the originals.
   */
  size_t n_value;
  int64_t *value;
  /*
   * label includes additional context for this sample. It can include
   * things like a thread id, allocation size, etc
   */
  size_t n_label;
  Perftools__Profiles__Label **label;
};
#define PERFTOOLS__PROFILES__SAMPLE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__sample__descriptor) \
    , 0,NULL, 0,NULL, 0,NULL }


struct  _Perftools__Profiles__Label
{
  ProtobufCMessage base;
  /*
   * Index into string table
   */
  int64_t key;
  /*
   * At most one of the following must be present
   */
  /*
   * Index into string table
   */
  int64_t str;
  int64_t num;
  /*
   * Should only be present when num is present.
   * Specifies the units of num.
   * Use arbitrary string (for example, "requests") as a custom count unit.
   * If no unit is specified, consumer may apply heuristic to deduce the unit.
   * Consumers may also  interpret units like "bytes" and "kilobytes" as memory
   * units and units like "seconds" and "nanoseconds" as time units,
   * and apply appropriate unit conversions to these.
   */
  /*
   * Index into string table
   */
  int64_t num_unit;
};
#define PERFTOOLS__PROFILES__LABEL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__label__descriptor) \
    , 0, 0, 0, 0 }


struct  _Perftools__Profiles__Mapping
{
  ProtobufCMessage base;
  /*
   * Unique nonzero id for the mapping.
   */
  uint64_t id;
  /*
   * Address at which the binary (or DLL) is loaded into memory.
   */
  uint64_t memory_start;
  /*
   * The limit of the address range occupied by this mapping.
   */
  uint64_t memory_limit;
  /*
   * Offset in the binary that corresponds to the first mapped address.
   */
  uint64_t file_offset;
  /*
   * The object this entry is loaded from.  This can be a filename on
   * disk for the main binary and shared libraries, or virtual
   * abstractions like "[vdso]".
   */
  /*
   * Index into string table
   */
  int64_t filename;
  /*
   * A string that uniquely identifies a particular program version
   * with high probability. E.g., for binaries generated by GNU tools,
   * it could be the contents of the .note.gnu.build-id field.
   */
  /*
   * Index into string table
   */
  int64_t build_id;
  /*
   * The following fields indicate the resolution of symbolic info.
   */
  protobuf_c_boolean has_functions;
  protobuf_c_boolean has_filenames;
  protobuf_c_boolean has_line_numbers;
  protobuf_c_boolean has_inline_frames;
};
#define PERFTOOLS__PROFILES__MAPPING__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__mapping__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


/*
 * Describes function and line table debug information.
 */
struct  _Perftools__Profiles__Location
{
  ProtobufCMessage base;
  /*
   * Unique nonzero id for the location.  A profile could use
   * instruction addresses or any integer sequence as ids.
   */
  uint64_t id;
  /*
   * The id of the corresponding profile.Mapping for this location.
   * It can be unset if the mapping is unknown or not applicable for
   * this profile type.
   */
  uint64_t mapping_id;
  /*
   * The instruction address for this location, if available.  It
   * should be within [Mapping.memory_start...Mapping.memory_limit]
   * for the corresponding mapping. A non-leaf address may be in the
   * middle of a call instruction. It is up to display tools to find
   * the beginning of the instruction if necessary.
   */
  uint64_t address;
  /*
   * Multiple line indicates this location has inlined functions,
   * where the last entry represents the caller into which the
   * preceding entries were inlined.
   * E.g., if memcpy() is inlined into printf:
   *    line[0].function_name == "memcpy"
   *    line[1].function_name == "printf"
   */
  size_t n_line;
  Perftools__Profiles__Line **line;
  /*
   * Provides an indication that multiple symbols map to this location's
   * address, for example due to identical code folding by the linker. In that
   * case the line information above represents one of the multiple
   * symbols. This field must be recomputed when the symbolization state of the
   * profile changes.
   */
  protobuf_c_boolean is_folded;
};
#define PERFTOOLS__PROFILES__LOCATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__location__descriptor) \
    , 0, 0, 0, 0,NULL, 0 }


struct  _Perftools__Profiles__Line
{
  ProtobufCMessage base;
  /*
   * The id of the corresponding profile.Function for this line.
   */
  uint64_t function_id;
  /*
   * Line number in source code.
   */
  int64_t line;
};
#define PERFTOOLS__PROFILES__LINE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__line__descriptor) \
    , 0, 0 }


struct  _Perftools__Profiles__Function
{
  ProtobufCMessage base;
  /*
   * Unique nonzero id for the function.
   */
  uint64_t id;
  /*
   * Name of the function, in human-readable form if available.
   */
  /*
   * Index into string table
   */
  int64_t name;
  /*
   * Name of the function, as identified by the system.
   * For instance, it can be a C++ mangled name.
   */
  /*
   * Index into string table
   */
  int64_t system_name;
  /*
   * Source file containing the function.
   */
  /*
   * Index into string table
   */
  int64_t filename;
  /*
   * Line number in source file.
   */
  int64_t start_line;
};
#define PERFTOOLS__PROFILES__FUNCTION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&perftools__profiles__function__descriptor) \
    , 0, 0, 0, 0, 0 }


/* Perftools__Profiles__Profile methods */
void   perftools__profiles__profile__init
                     (Perftools__Profiles__Profile         *message);
size_t perftools__profiles__profile__get_packed_size
                     (const Perftools__Profiles__Profile   *message);
size_t perftools__profiles__profile__pack
                     (const Perftools__Profiles__Profile   *message,
                      uint8_t             *out);
size_t perftools__profiles__profile__pack_to_buffer
                     (const Perftools__Profiles__Profile   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__Profile *
       perftools__profiles__profile__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__profile__free_unpacked
                     (Perftools__Profiles__Profile *message,
                      ProtobufCAllocator *allocator);
/* Perftools__Profiles__ValueType methods */
void   perftools__profiles__value_type__init
                     (Perftools__Profiles__ValueType         *message);
size_t perftools__profiles__value_type__get_packed_size
                     (const Perftools__Profiles__ValueType   *message);
size_t perftools__profiles__value_type__pack
                     (const Perftools__Profiles__ValueType   *message,
                      uint8_t             *out);
size_t perftools__profiles__value_type__pack_to_buffer
                     (const Perftools__Profiles__ValueType   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__ValueType *
       perftools__profiles__value_type__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__value_type__free_unpacked
                     (Perftools__Profiles__ValueType *message,
                      ProtobufCAllocator *allocator);
/* Perftools__Profiles__Sample methods */
void   perftools__profiles__sample__init
                     (Perftools__Profiles__Sample         *message);
size_t perftools__profiles__sample__get_packed_size
                     (const Perftools__Profiles__Sample   *message);
size_t perftools__profiles__sample__pack
                     (const Perftools__Profiles__Sample   *message,
                      uint8_t             *out);
size_t perftools__profiles__sample__pack_to_buffer
                     (const Perftools__Profiles__Sample   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__Sample *
       perftools__profiles__sample__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__sample__free_unpacked
                     (Perftools__Profiles__Sample *message,
                      ProtobufCAllocator *allocator);
/* Perftools__Profiles__Label methods */
void   perftools__profiles__label__init
                     (Perftools__Profiles__Label         *message);
size_t perftools__profiles__label__get_packed_size
                     (const Perftools__Profiles__Label   *message);
size_t perftools__profiles__label__pack
                     (const Perftools__Profiles__Label   *message,
                      uint8_t             *out);
size_t perftools__profiles__label__pack_to_buffer
                     (const Perftools__Profiles__Label   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__Label *
       perftools__profiles__label__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__label__free_unpacked
                     (Perftools__Profiles__Label *message,
                      ProtobufCAllocator *allocator);
/* Perftools__Profiles__Mapping methods */
void   perftools__profiles__mapping__init
                     (Perftools__Profiles__Mapping         *message);
size_t perftools__profiles__mapping__get_packed_size
                     (const Perftools__Profiles__Mapping   *message);
size_t perftools__profiles__mapping__pack
                     (const Perftools__Profiles__Mapping   *message,
                      uint8_t             *out);
size_t perftools__profiles__mapping__pack_to_buffer
                     (const Perftools__Profiles__Mapping   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__Mapping *
       perftools__profiles__mapping__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__mapping__free_unpacked
                     (Perftools__Profiles__Mapping *message,
                      ProtobufCAllocator *allocator);
/* Perftools__Profiles__Location methods */
void   perftools__profiles__location__init
                     (Perftools__Profiles__Location         *message);
size_t perftools__profiles__location__get_packed_size
                     (const Perftools__Profiles__Location   *message);
size_t perftools__profiles__location__pack
                     (const Perftools__Profiles__Location   *message,
                      uint8_t             *out);
size_t perftools__profiles__location__pack_to_buffer
                     (const Perftools__Profiles__Location   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__Location *
       perftools__profiles__location__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__location__free_unpacked
                     (Perftools__Profiles__Location *message,
                      ProtobufCAllocator *allocator);
/* Perftools__Profiles__Line methods */
void   perftools__profiles__line__init
                     (Perftools__Profiles__Line         *message);
size_t perftools__profiles__line__get_packed_size
                     (const Perftools__Profiles__Line   *message);
size_t perftools__profiles__line__pack
                     (const Perftools__Profiles__Line   *message,
                      uint8_t             *out);
size_t perftools__profiles__line__pack_to_buffer
                     (const Perftools__Profiles__Line   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__Line *
       perftools__profiles__line__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__line__free_unpacked
                     (Perftools__Profiles__Line *message,
                      ProtobufCAllocator *allocator);
/* Perftools__Profiles__Function methods */
void   perftools__profiles__function__init
                     (Perftools__Profiles__Function         *message);
size_t perftools__profiles__function__get_packed_size
                     (const Perftools__Profiles__Function   *message);
size_t perftools__profiles__function__pack
                     (const Perftools__Profiles__Function   *message,
                      uint8_t             *out);
size_t perftools__profiles__function__pack_to_buffer
                     (const Perftools__Profiles__Function   *message,
                      ProtobufCBuffer     *buffer);
Perftools__Profiles__Function *
       perftools__profiles__function__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   perftools__profiles__function__free_unpacked
                     (Perftools__Profiles__Function *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Perftools__Profiles__Profile_Closure)
                 (const Perftools__Profiles__Profile *message,
                  void *closure_data);
typedef void (*Perftools__Profiles__ValueType_Closure)
                 (const Perftools__Profiles__ValueType *message,
                  void *closure_data);
typedef void (*Perftools__Profiles__Sample_Closure)
                 (const Perftools__Profiles__Sample *message,
                  void *closure_data);
typedef void (*Perftools__Profiles__Label_Closure)
                 (const Perftools__Profiles__Label *message,
                  void *closure_data);
typedef void (*Perftools__Profiles__Mapping_Closure)
                 (const Perftools__Profiles__Mapping *message,
                  void *closure_data);
typedef void (*Perftools__Profiles__Location_Closure)
                 (const Perftools__Profiles__Location *message,
                  void *closure_data);
typedef void (*Perftools__Profiles__Line_Closure)
                 (const Perftools__Profiles__Line *message,
                  void *closure_data);
typedef void (*Perftools__Profiles__Function_Closure)
                 (const Perftools__Profiles__Function *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor perftools__profiles__profile__descriptor;
extern const ProtobufCMessageDescriptor perftools__profiles__value_type__descriptor;
extern const ProtobufCMessageDescriptor perftools__profiles__sample__descriptor;
extern const ProtobufCMessageDescriptor perftools__profiles__label__descriptor;
extern const ProtobufCMessageDescriptor perftools__profiles__mapping__descriptor;
extern const ProtobufCMessageDescriptor perftools__profiles__location__descriptor;
extern const ProtobufCMessageDescriptor perftools__profiles__line__descriptor;
extern const ProtobufCMessageDescriptor perftools__profiles__function__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_proto_2fprofile_2eproto__INCLUDED */
